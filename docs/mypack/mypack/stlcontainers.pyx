###################
###  WARNING!!! ###
###################
# This file has been autogenerated

# Cython imports
from cython.operator cimport dereference as deref
from cython.operator cimport preincrement as inc
from libc.stdlib cimport malloc, free
from libc.string cimport memcpy
from libcpp.string cimport string as std_string
from libcpp.utility cimport pair
from libcpp.map cimport map as cpp_map
from libcpp.set cimport set as cpp_set
from libcpp cimport bool as cpp_bool
from libcpp.vector cimport vector as cpp_vector
from cpython.version cimport PY_MAJOR_VERSION

# Python Imports
import collections

cimport numpy as np
import numpy as np

np.import_array()

cimport mypack_extra_types

# Cython Imports For Types
cimport dtypes
cimport mypack_extra_types
from libcpp.string cimport string as std_string

# Imports For Types
import dtypes

if PY_MAJOR_VERSION >= 3:
    basestring = str

# Dirty ifdef, else, else preprocessor hack
# see http://comments.gmane.org/gmane.comp.python.cython.user/4080
cdef extern from *:
    cdef void emit_ifpy2k "#if PY_MAJOR_VERSION == 2 //" ()
    cdef void emit_ifpy3k "#if PY_MAJOR_VERSION == 3 //" ()
    cdef void emit_else "#else //" ()
    cdef void emit_endif "#endif //" ()

# std_string vector


# SetUInt
cdef class _SetIterUInt(object):
    cdef void init(self, cpp_set[mypack_extra_types.uint32] * set_ptr):
        cdef cpp_set[mypack_extra_types.uint32].iterator * itn = <cpp_set[mypack_extra_types.uint32].iterator *> malloc(sizeof(set_ptr.begin()))
        itn[0] = set_ptr.begin()
        self.iter_now = itn

        cdef cpp_set[mypack_extra_types.uint32].iterator * ite = <cpp_set[mypack_extra_types.uint32].iterator *> malloc(sizeof(set_ptr.end()))
        ite[0] = set_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_set[mypack_extra_types.uint32].iterator inow = deref(self.iter_now)
        cdef cpp_set[mypack_extra_types.uint32].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow))
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval


cdef class _SetUInt:
    def __cinit__(self, new_set=True, bint free_set=True):
        cdef mypack_extra_types.uint32 s
        cdef cpp_set[mypack_extra_types.uint32] * set_ptr


        # Decide how to init set, if at all
        if isinstance(new_set, _SetUInt):
            self.set_ptr = (<_SetUInt> new_set).set_ptr
        elif isinstance(new_set, np.generic) and np.PyArray_DescrFromScalar(new_set).type_num == np.NPY_UINT32:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.set_ptr == NULL:
                self.set_ptr = new cpp_set[mypack_extra_types.uint32]()
            np.PyArray_ScalarAsCtype(new_set, &set_ptr)
            self.set_ptr[0] = set_ptr[0]
        elif hasattr(new_set, '__iter__') or \
                (hasattr(new_set, '__len__') and
                hasattr(new_set, '__getitem__')):
            self.set_ptr = new cpp_set[mypack_extra_types.uint32]()
            for value in new_set:

                s = <mypack_extra_types.uint32> long(value)
                self.set_ptr.insert(s)
        elif bool(new_set):
            self.set_ptr = new cpp_set[mypack_extra_types.uint32]()

        # Store free_set
        self._free_set = free_set

    def __dealloc__(self):
        if self._free_set:
            del self.set_ptr

    def __contains__(self, value):
        cdef mypack_extra_types.uint32 s

        if isinstance(value, int):

            s = <mypack_extra_types.uint32> long(value)
        else:
            return False

        if 0 < self.set_ptr.count(s):
            return True
        else:
            return False

    def __len__(self):
        return self.set_ptr.size()

    def __iter__(self):
        cdef _SetIterUInt si = _SetIterUInt()
        si.init(self.set_ptr)
        return si

    def add(self, value):
        cdef mypack_extra_types.uint32 v


        v = <mypack_extra_types.uint32> long(value)
        self.set_ptr.insert(v)
        return

    def discard(self, value):
        cdef mypack_extra_types.uint32 v

        if value in self:

            v = <mypack_extra_types.uint32> long(value)
            self.set_ptr.erase(v)
        return


class SetUInt(_SetUInt, collections.Set):
    """Wrapper class for C++ standard library sets of type <unsigned integer>.
    Provides set like interface on the Python level.


    Parameters
    ----------
    new_set : bool or set-like
        Boolean on whether to make a new set or not, or set-like object
        with values which are castable to the appropriate type.
    free_set : bool
        Flag for whether the pointer to the C++ set should be deallocated
        when the wrapper is dereferenced.

    """
    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "set([" + ", ".join([repr(i) for i in self]) + "])"



# Map(Int, Double)
cdef class _MapIterIntDouble(object):
    cdef void init(self, cpp_map[int, double] * map_ptr):
        cdef cpp_map[int, double].iterator * itn = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.begin()))
        itn[0] = map_ptr.begin()
        self.iter_now = itn

        cdef cpp_map[int, double].iterator * ite = <cpp_map[int, double].iterator *> malloc(sizeof(map_ptr.end()))
        ite[0] = map_ptr.end()
        self.iter_end = ite

    def __dealloc__(self):
        free(self.iter_now)
        free(self.iter_end)

    def __iter__(self):
        return self

    def __next__(self):
        cdef cpp_map[int, double].iterator inow = deref(self.iter_now)
        cdef cpp_map[int, double].iterator iend = deref(self.iter_end)

        if inow != iend:

            pyval = int(deref(inow).first)
        else:
            raise StopIteration

        inc(deref(self.iter_now))
        return pyval

cdef class _MapIntDouble:
    def __cinit__(self, new_map=True, bint free_map=True):
        cdef pair[int, double] item
        cdef cpp_map[int, double] * map_ptr



        # Decide how to init map, if at all
        if isinstance(new_map, _MapIntDouble):
            self.map_ptr = (<_MapIntDouble> new_map).map_ptr
        elif isinstance(new_map, np.generic) and np.PyArray_DescrFromScalar(new_map).type_num == np.NPY_OBJECT:
            # scalars are copies, sadly not views, so we need to re-copy
            if self.map_ptr == NULL:
                self.map_ptr = new cpp_map[int, double]()
            np.PyArray_ScalarAsCtype(new_map, &map_ptr)
            self.map_ptr[0] = map_ptr[0]
        elif hasattr(new_map, 'items'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map.items():


                item = pair[int, double](<int> key, <double> value)
                self.map_ptr.insert(item)
        elif hasattr(new_map, '__len__'):
            self.map_ptr = new cpp_map[int, double]()
            for key, value in new_map:


                item = pair[int, double](<int> key, <double> value)
                self.map_ptr.insert(item)
        elif bool(new_map):
            self.map_ptr = new cpp_map[int, double]()

        # Store free_map
        self._free_map = free_map

    def __dealloc__(self):
        if self._free_map:
            del self.map_ptr

    def __contains__(self, key):
        cdef int k

        if not isinstance(key, int):
            return False

        k = <int> key

        if 0 < self.map_ptr.count(k):
            return True
        else:
            return False

    def __len__(self):
        return self.map_ptr.size()

    def __iter__(self):
        cdef _MapIterIntDouble mi = _MapIterIntDouble()
        mi.init(self.map_ptr)
        return mi

    def __getitem__(self, key):
        cdef int k
        cdef double v


        if not isinstance(key, int):
            raise TypeError("Only integer keys are valid.")

        k = <int> key

        if 0 < self.map_ptr.count(k):
            v = deref(self.map_ptr)[k]

            return float(deref(self.map_ptr)[k])
        else:
            raise KeyError

    def __setitem__(self, key, value):


        cdef pair[int, double] item


        item = pair[int, double](<int> key, <double> value)
        if 0 < self.map_ptr.count(<int> key):
            self.map_ptr.erase(<int> key)
        self.map_ptr.insert(item)

    def __delitem__(self, key):
        cdef int k

        if key in self:

            k = <int> key
            self.map_ptr.erase(k)


class MapIntDouble(_MapIntDouble, collections.MutableMapping):
    """Wrapper class for C++ standard library maps of type <integer, double>.
    Provides dictionary like interface on the Python level.

    Parameters
    ----------
    new_map : bool or dict-like
        Boolean on whether to make a new map or not, or dict-like object
        with keys and values which are castable to the appropriate type.
    free_map : bool
        Flag for whether the pointer to the C++ map should be deallocated
        when the wrapper is dereferenced.
    """

    def __str__(self):
        return self.__repr__()

    def __repr__(self):
        return "{" + ", ".join(["{0}: {1}".format(repr(key), repr(value)) for key, value in self.items()]) + "}"



